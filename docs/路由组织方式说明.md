# Go Web 路由组织方式说明

## 当前实现方式：模块化路由注册

这是 Go 中最主流和推荐的路由组织方式，类似于 C# 中的特性类（Attribute）方式。

### 实现原理

每个业务模块提供自己的路由注册函数，在统一的路由注册文件中调用。

### 目录结构

```
internal/handlers/
├── routes.go          # 统一路由注册入口（类似 C# 的 Startup.cs）
├── router.go          # 各模块路由注册函数
├── auth_handler.go     # 认证处理器
├── user_handler.go     # 用户处理器
└── ...
```

### 代码示例

#### 1. 统一路由注册（routes.go）

```go
package handlers

import "github.com/gin-gonic/gin"

// RegisterAllRoutes 注册所有路由
func RegisterAllRoutes(r *gin.Engine) {
	api := r.Group("/api/v1")
	{
		RegisterAuthRoutes(api)
		RegisterUserRoutes(api)
		// 添加新模块只需一行
		RegisterFamilyRoutes(api)
	}
}
```

#### 2. 模块路由注册（router.go）

```go
package handlers

import (
	"github.com/gin-gonic/gin"
	"onetaste-family/backend/internal/middleware"
)

// RegisterAuthRoutes 注册认证相关路由
func RegisterAuthRoutes(api *gin.RouterGroup) {
	authHandler := NewAuthHandler()
	
	auth := api.Group("/auth")
	{
		auth.POST("/register", authHandler.Register)
		auth.POST("/login", authHandler.Login)
	}
}

// RegisterUserRoutes 注册用户相关路由
func RegisterUserRoutes(api *gin.RouterGroup) {
	userHandler := NewUserHandler()
	
	user := api.Group("/user")
	user.Use(middleware.AuthMiddleware())
	{
		user.GET("/info", userHandler.GetUserInfo)
	}
}
```

#### 3. 主程序（main.go）

```go
func main() {
	// ... 初始化配置、数据库等
	
	r := gin.Default()
	r.Use(corsMiddleware())
	
	// 一行代码注册所有路由
	handlers.RegisterAllRoutes(r)
	
	r.Run(addr)
}
```

### 优势

1. **模块化**：每个模块的路由逻辑独立管理
2. **可维护性**：main.go 保持简洁，只负责应用初始化
3. **可扩展性**：添加新模块只需两步
4. **清晰性**：路由结构一目了然
5. **测试友好**：可以单独测试每个模块的路由

---

## 其他可选方式

### 方式1：接口方式（类似 C# 的接口实现）

定义路由接口，每个 handler 实现该接口：

```go
// router.go
type Router interface {
	RegisterRoutes(router *gin.RouterGroup)
}

// auth_handler.go
func (h *AuthHandler) RegisterRoutes(router *gin.RouterGroup) {
	auth := router.Group("/auth")
	{
		auth.POST("/register", h.Register)
		auth.POST("/login", h.Login)
	}
}

// routes.go
func RegisterAllRoutes(r *gin.Engine) {
	api := r.Group("/api/v1")
	
	routers := []Router{
		NewAuthHandler(),
		NewUserHandler(),
	}
	
	for _, router := range routers {
		router.RegisterRoutes(api)
	}
}
```

**适用场景**：需要更严格的类型约束和统一接口

### 方式2：路由配置文件方式

使用配置文件定义路由：

```go
// routes.yaml
routes:
  - path: /auth/register
    method: POST
    handler: AuthHandler.Register
    middleware: []
  - path: /user/info
    method: GET
    handler: UserHandler.GetUserInfo
    middleware: [auth]
```

**适用场景**：路由需要动态配置或从外部加载

### 方式3：装饰器模式（类似 Python 的装饰器）

```go
// 定义路由装饰器
func AuthRequired() gin.HandlerFunc {
	return middleware.AuthMiddleware()
}

// 在 handler 中使用
func (h *UserHandler) GetUserInfo(c *gin.Context) {
	// ...
}

// 注册时应用装饰器
user.GET("/info", AuthRequired(), userHandler.GetUserInfo)
```

**适用场景**：需要灵活组合中间件

---

## 推荐方案对比

| 方式 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **模块化路由注册（当前）** | 简单直观、易维护、Go 主流做法 | 需要手动注册 | **推荐：中小型项目** |
| 接口方式 | 类型安全、统一接口 | 代码稍复杂 | 大型项目、需要严格类型约束 |
| 配置文件 | 灵活、可动态配置 | 需要解析配置、类型不安全 | 需要动态路由的场景 |
| 装饰器模式 | 灵活组合中间件 | 不够直观 | 中间件组合复杂的场景 |

---

## 实际项目示例

### 添加家庭模块路由

#### 步骤1：创建 family_handler.go

```go
package handlers

type FamilyHandler struct {
	familyService *services.FamilyService
}

func NewFamilyHandler() *FamilyHandler {
	return &FamilyHandler{
		familyService: services.NewFamilyService(),
	}
}

func (h *FamilyHandler) Create(c *gin.Context) {
	// 实现创建家庭逻辑
}

func (h *FamilyHandler) GetInfo(c *gin.Context) {
	// 实现获取家庭信息逻辑
}
```

#### 步骤2：在 router.go 中添加路由注册函数

```go
// RegisterFamilyRoutes 注册家庭相关路由
func RegisterFamilyRoutes(api *gin.RouterGroup) {
	familyHandler := NewFamilyHandler()
	
	family := api.Group("/family")
	family.Use(middleware.AuthMiddleware()) // 需要认证
	{
		family.POST("/create", familyHandler.Create)
		family.GET("/info", familyHandler.GetInfo)
		family.POST("/member/invite", familyHandler.InviteMember)
		family.GET("/members", familyHandler.GetMembers)
	}
}
```

#### 步骤3：在 routes.go 中注册

```go
func RegisterAllRoutes(r *gin.Engine) {
	api := r.Group("/api/v1")
	{
		RegisterAuthRoutes(api)
		RegisterUserRoutes(api)
		RegisterFamilyRoutes(api)  // 添加这一行
	}
}
```

**完成！** 只需三步，新模块的路由就注册好了。

---

## 总结

当前采用的**模块化路由注册**方式是 Go 社区最主流和推荐的做法，具有以下特点：

1. ✅ **简单直观**：代码结构清晰，易于理解
2. ✅ **易于维护**：每个模块的路由集中管理
3. ✅ **易于扩展**：添加新模块只需少量代码
4. ✅ **符合 Go 习惯**：遵循 Go 社区的常见实践
5. ✅ **测试友好**：可以单独测试每个模块

这种方式虽然不是通过特性（Attribute）自动发现路由，但通过函数注册的方式，在 Go 中已经是最接近 C# 特性类方式的实现，并且更加灵活和可控。

